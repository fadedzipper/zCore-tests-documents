# 开源os夏令营总结文档
### 夏令营内容
* 学习了rust语言的使用和体会到了用rust写os的好处和优势。
* 学习了rcore-tutorial和zcore-tutorial的部分，rcore涉及一个经典的抢占式的操作系统的设计。zcore在内核部分是基于协作的进程间的切换设计。
* 写了一部分zcore-tutorial第四章的部分，之后会继续去完善它。

### 总结和思考
* rust写os有很多的优势，第一个就是rust的生态比c/c++要好很多。工具链和生态结合的很好，使得可以方便的进行代码的复用，减少重复造轮子和不必要的工作量。通过控制unsafe代码的使用，可以有效利用rust编译器的特性，是的内核编写的更加安全。
* 关于调试。通过查看很多资料，调试这样比较底层和大型的代码用的比较多的还是log系统。通过分级的log可以实现对于程序执行流程的观测。因为调bug首先需要对于程序流程进行精确的把握。log往往指示出了不符合预期的情况，需要对于代码理解很精准。
* zcore是一个很有特色的os。内核里面的线程并没有每个线程的独立的内核栈，是无栈的协作式的并发。利用了rust语言的async和await机制，实现了这种技术。能够加快线程之间切换的速度，因为协作式的并发并不支持抢占，不支持在任意程序执行位置抢占，仅仅在切换的位置保存了下一个阶段需要使用到的信息。这就节省了内存资源。没有内核栈的分配也可以节省大量的内存。协作的线程对于一些实时性强的系统调用其实也提出了比较高的要求。和抢占式系统相比哪个好还需要进一步的验证。
* 关于async和await机制的学习其实花费了很多的精力，这个也是学习rust的过程中一个比较大的低谷，其实花费时间看了很多的资料。看了这些资料之后对于这个机制才形成了比较完整的正确认识。比如洛佳维护的blogos的async await机制的中文版。这个教程是相对来说最容易理解和掌握的。还有200行代码之类的资料包括rust编程之道等等。
* 总的来说，对于这个机制的理解。future对象其实分为三种。顶层的future是被调度器直接调度的对象。调度器可以用各种各样的实现。有很多现成的库可以去使用。尤其是在std环境里面。在zcore里面，有一个自己实现的简易的调度器。底层future其实真正的对应了基本的资源的等待。会自己注册waker对象来进行事件等到之后应该去唤醒的操作。waker其实是和调度器相关联的。所以一般库把他们封装到了一起。rust语言自己提供的机制本质上是方便的把底层future结合成中层future的机制。尤其是像写常规程序一样的把底层future结合成中层future。
### 不足
最后没有做总结汇报，感觉还是对于rust和操作系统的把握不是很到位。对于x86汇编的问题其实也拖了一些后腿。将来会继续关注这个项目，把它写的更加完善。